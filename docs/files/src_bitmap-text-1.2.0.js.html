<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/bitmap-text-1.2.0.js - BitmapText</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="BitmapText"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.2.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Kiwi.Plugins.BitmapText.html">Kiwi.Plugins.BitmapText</a></li>
            
                <li><a href="../classes/Kiwi.Plugins.GameObjects.BitmapText.html">Kiwi.Plugins.GameObjects.BitmapText</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/Kiwi.html">Kiwi</a></li>
            
                <li><a href="../modules/Plugins.html">Plugins</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/bitmap-text-1.2.0.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
Kiwi.Plugins.BitmapText = {

	/**
	Plugin data for &#x60;BitmapText&#x60;.

	Use &#x60;Kiwi.Plugins.GameObjects.BitmapText&#x60; for the actual object.

	@module Kiwi
	@submodule Plugins
	@namespace Kiwi.Plugins
	@class BitmapText
	**/

	/**
	Name of this plugin

	@property name
	@type string
	@default &quot;BitmapText&quot;
	@public
	**/
	name: &quot;BitmapText&quot;,

	/**
	Version of this plugin.

	@property version
	@type string
	@default &quot;1.2.0&quot;
	**/
	version: &quot;1.2.0&quot;
};

Kiwi.PluginManager.register( Kiwi.Plugins.BitmapText );


// Do Kiwi Plugin GameObjects Exist?
if ( typeof Kiwi.Plugins.GameObjects == &quot;undefined&quot; ) {
	Kiwi.Plugins.GameObjects = {};
}

Kiwi.Plugins.GameObjects.BitmapText = function( state, atlas, text, x, y ) {

	/**
	GameObject to display bitmap text.
	Works in a very similar fashion to the default &#x60;TextField&#x60; GameObject
	included in the core of KiwiJS, except this one uses a TextureAtlas
	instead of a font.

	You can also set the maximum width of the Text to span multiple lines.

	@class BitmapText
	@extends Entity
	@namespace Kiwi.Plugins.GameObjects
	@constructor
	@param state {Kiwi.State} State that this gameobject belongs to
	@param atlas {TextureAtlas|SpriteSheet} Spritesheet or textureatlas
		that holds the font.
	@param text {string} Text to display. Can be changed later.
	@param x {number} Horizontal coordinate
	@param y {number} Vertical coordinate
	**/

	Kiwi.Entity.call( this, state, x, y );

	if ( typeof text == &quot;undefined&quot; ) {
		text = null;
	}

	/**
	Which way the text should be in alignment.

	@property _align
	@type number
	@default LEFT
	@private
	**/
	this._align = Kiwi.Plugins.GameObjects.BitmapText.LEFT;

	/**
	Reference of which cell of the atlas is used for each string character.
	This isn&#x27;t a robust object - it doesn&#x27;t contain every character possible.
	You should add references as necessary.

	@property _alphabeticalCells
	@private
	@type array
	**/
	this._alphabeticalCells = {
		a:26,    A:0,
		b:27,    B:1,
		c:28,    C:2,
		d:29,    D:3,
		e:30,    E:4,
		f:31,    F:5,
		g:32,    G:6,
		h:33,    H:7,
		i:34,    I:8,
		j:35,    J:9,
		k:36,    K:10,
		l:37,    L:11,
		m:38,    M:12,
		n:39,    N:13,
		o:40,    O:14,
		p:41,    P:15,
		q:42,    Q:16,
		r:43,    R:17,
		s:44,    S:18,
		t:45,    T:19,
		u:46,    U:20,
		v:47,    V:21,
		w:48,    W:22,
		x:49,    X:23,
		y:50,    Y:24,
		z:51,    Z:25,
		&quot;0&quot;:52,  &quot;1&quot;:53,
		&quot;2&quot;:54,  &quot;3&quot;:55,
		&quot;4&quot;:56,  &quot;5&quot;:57,
		&quot;6&quot;:58,  &quot;7&quot;:59,
		&quot;8&quot;:60,  &quot;9&quot;:61,
		&quot;.&quot;:62,  &quot;$&quot;:63,
		&quot;,&quot;:64,  &quot;!&quot;:65,
		&quot;#&quot;:66,  &quot; &quot;:67
	};

	/**
	Property used to decide which characters should go on which lines

	@property _lines
	@type array
	@private
	**/
	this._lines = [];

	/**
	Whether the text should be smooth; that is,
	whether CANVAS should enable image smoothing,
	or WebGL should use LINEAR or NEAREST texture blending.

	Note: CANVAS support is still experimental,
	and may default to smooth.

	@property _smooth
	@type boolean
	@default false
	@private
	**/
	this._smooth = false;

	/**
	Whether the gameobject is &quot;dirty&quot; and needs &quot;re-rendering&quot;

	@property _tempDirty
	@type boolean
	@private
	**/
	this._tempDirty = true;

	/**
	Texture atlas that the bitmapText relies on

	@property atlas
	@type Kiwi.Textures.TextureAtlas
	@public
	**/
	this.atlas = atlas;

	/**
	Default cell to be used when a cell could not be found
	for a particular character.

	Currently the default is the same as what a &quot;space&quot; would be.

	@property defaultCell
	@type number
	@default 67
	@public
	**/
	this.defaultCell = 67;

	/**
	The maximum width of the TextField. Set to &#x60;null&#x60; if
	no maximum width is desired, i.e. if the text is to be all on one line.

	@property maxWidth
	@type number
	@default null
	@public
	**/
	this.maxWidth = null;

	/**
	Punctation characters that are used to separate words
	but stay on at the end of word they are attached to.

	@property punctionationChars
	@type array
	@public
	**/
	this.punctionationChars = [ &quot;.&quot;, &quot;!&quot;, &quot;?&quot;, &quot;:&quot;, &quot;;&quot;, &quot;,&quot;, &quot;-&quot; ];

	/**
	Whether the atlas used is &quot;supported&quot;

	@property supported
	@type boolean
	@public
	**/
	this.supported = true;

	/**
	Text to be rendered

	@property text
	@type string
	@private
	**/
	this.text = text;


	// Check to see if a valid atlas was passed.
	if ( this.atlas.type == Kiwi.Textures.TextureAtlas.SINGLE_IMAGE ) {

		this.supported = false;
		if ( this.game.debugOption == Kiwi.DEBUG_ON ) {
			Kiwi.Log.warn(
				&quot;Single Images will not work &quot; +
				&quot;with the Bitmap Text GameObject!&quot; );
		}

	} else {

		if ( this.game.renderOption === Kiwi.RENDERER_WEBGL ) {
			this.glRenderer = this.game.renderer.requestSharedRenderer(
				&quot;TextureAtlasRenderer&quot; );

			/**
			Temporary point used to compute screen coordinates

			@property _pt1
			@type Kiwi.Geom.Point
			@private
			**/
			this._pt1 = new Kiwi.Geom.Point();

			/**
			Temporary point used to compute screen coordinates

			@property _pt2
			@type Kiwi.Geom.Point
			@private
			**/
			this._pt2 = new Kiwi.Geom.Point();

			/**
			Temporary point used to compute screen coordinates

			@property _pt3
			@type Kiwi.Geom.Point
			@private
			**/
			this._pt3 = new Kiwi.Geom.Point();

			/**
			Temporary point used to compute screen coordinates

			@property _pt4
			@type Kiwi.Geom.Point
			@private
			**/
			this._pt4 = new Kiwi.Geom.Point();

		} else {

			/**
			Canvas to which the text is rendered, and is then rendered
			to the stage.

			Only created in CANVAS rendering mode.

			@property _tempCanvas
			@type HTMLCanvasElement
			@private
			**/
			this._tempCanvas = document.createElement( &quot;canvas&quot; );

			// Set the inital width/height to be base2.
			// Will be overriden the first time the text is rendered.
			this._tempCanvas.width = 2;
			this._tempCanvas.height = 2;

			/**
			2d context for the temporary canvas.

			Only created in CANVAS rendering mode.

			@property _tempCtx
			@type HTMLCanvasContent
			@default undefined
			@private
			**/
			this._tempCtx = this._tempCanvas.getContext( &quot;2d&quot; );
		}

		/**
		Width (or what it should be) of the text.

		@property _tempWidth
		@type number
		@private
		**/
		this._tempWidth = 0;

		/**
		Height (or what it should be) of the text

		@property _tempHeight
		@type number
		@private
		**/
		this._tempHeight = 0;

		/**
		Current &quot;word&quot; whose individual character lines are being determined.

		@property _tempWord
		@type array
		@private
		**/
		this._tempWord = [];

	}

	this._setTextureSharpness( this._smooth );
};


Kiwi.extend( Kiwi.Plugins.GameObjects.BitmapText, Kiwi.Entity );


Object.defineProperties(
	Kiwi.Plugins.GameObjects.BitmapText.prototype,
	{
		&quot;alphabeticalCells&quot;: {

			/**
			Reference of which cell of the atlas is used
			for each string character.
			This isn&#x27;t a robust object -
			it doesn&#x27;t contain every character possible.
			You should add references as necessary.

			@property alphabeticalCells
			@public
			@type array
			**/

			get: function() {
				return this._alphabeticalCells;
			},
			set: function( val ) {

				// Re-render
				this._tempDirty = true;
				this._alphabeticalCells = val;
			},
			enumerable: true,
			configurable: true
		},

		&quot;align&quot;: {

			/**
			Which way the text should be aligned

			@property align
			@type number
			@public
			@default LEFT
			**/

			get: function() {
				return this._align;
			},
			set: function( val ) {

				// Re-render
				this._tempDirty = true;
				this._align = val;
			},
			enumerable: true,
			configurable: true
		},

		&quot;smooth&quot;: {

			/**
			Whether the texture should be sampled with linear pixel blends,
			or should just use sharp &quot;NEAREST&quot; sampling.

			Support is only guaranteed for WebGL for now,
			but most browsers support the necessary functions
			for sharp CANVAS rendering.

			@property smooth
			@type boolean
			@default false
			**/

			get: function() {
				return this._smooth;
			},
			set: function( value ) {

				this._smooth = value;
				this._setTextureSharpness( value );
			}
		},

		&quot;text&quot;: {

			/**
			Text to be rendered in the BitmapTextfield

			@property text
			@type string
			@public
			**/

			get: function() {
				return this._text;
			},
			set: function( val ) {

				// Re-render
				this._tempDirty = true;
				this._text = val;
			},
			enumerable: true,
			configurable: true
		},

		&quot;width&quot;: {

			/**
			The actual width of the text. This property is READ ONLY,
			and does not directly affect anything.

			@property width
			@type number
			@public
			**/

			get: function() {
				return this._tempWidth;
			},
			enumerable: true,
			configurable: true
		}
	} );


Kiwi.Plugins.GameObjects.BitmapText.remap = function( list, obj ) {

	/**
	Update all the &#x60;alphabeticalCells&#x60; of bitmaptext objects passed
	to a reference object.

	Note: This just calls the remap method on the gameobjects.

	@method remap
	@static
	@param list {array} List of &#x60;BitmapText&#x60; objects
	@param obj {object} Remap object
	@public
	**/

	for ( var bgo in list ) {
		list[ bgo ].remap( obj );
	}

};


Kiwi.Plugins.GameObjects.BitmapText.prototype._addTempWord = function() {

	/**
	Start to add the &#x60;_tempWord&#x60; to the lines.

	@method _addTempWord
	@private
	**/

	var charCell, line, t;

	if (
		typeof this._tempWord[ 0 ] !== &quot;undefined&quot; &amp;&amp;
		this._tempWord[ this._tempWord.length - 1 ].line -
			this._tempWord[ 0 ].line &gt; 1 ) {

		this._multiLineTextBreak();

	} else {

		line = this._lines[ this._lines.length - 1 ];

		// Loop through the word, and add it to the current line.
		for ( t = 0; t &lt; this._tempWord.length; t++ ) {
			charCell = this._tempWord[ t ].cell;

			// Don&#x27;t print leading spaces
			if ( line.text.length === 0 &amp;&amp;
				this._tempWord[ t ].char === &quot; &quot; ) {

				continue;
			}

			line.text.push( charCell );
			line.width += charCell.w;
		}

		// Reset the tempWord.
		this._tempWord.length = 0;

	}
};


Kiwi.Plugins.GameObjects.BitmapText.prototype._multiLineText = function() {

	/**
	Figure out which cell is to be used for each character in the text.
	Also figure out which lines the characters/words should go on.
	This method is used for BitmapText objects with a maximum width set
	(as they could span multiple lines).

	Should NOT be called by the developer/external objects.

	@method _multiLineText
	@private
	**/

	var i, cell, cw, w,
		newline = false;

	// Contains the cells/characters of the last word that is to be added.
	this._tempWord = [];

	// Calculate the height/width?...
	for ( i = 0; i &lt; this.text.length; i++ ) {

		// Get the cell relating to the current text.
		cell = this.atlas.cells[ this.cellNumber( this.text[ i ] ) ];

		if ( typeof cell !== &quot;undefined&quot; &amp;&amp; typeof cell !== null ) {

			// This is a new space?
			if (
				this.text[ i ] === &quot; &quot; ||
				this._tempWord.length === 1 &amp;&amp;
				this._tempWord[ 0 ].char === &quot; &quot;
				) {

				this._addTempWord();
			}

			// Get what would be the new width
			cw = this._tempWidth + parseInt( cell.w, 10 );

			// Would it extend past the maxWidth?
			if ( cw &gt;= this.maxWidth ) {

				// Calculate the current width of the new line.
				this._tempWidth = 0;
				for ( w = 0; w &lt; this._tempWord.length; w++ ) {
					this._tempWidth +=
						parseInt( this._tempWord[ w ].cell.w, 10 );
				}
				this._tempWidth += parseInt( cell.w, 10 );

				// Generate the new line
				this._lines.push( {
					text: [],
					height: 0,
					width: 0
				} );

			// Otherwise add the width to it
			} else {
				this._tempWidth = cw;
			}

			// Does the new height extend past the regular height?
			if ( this._lines[ this._lines.length - 1 ].height &lt; cell.h ) {
				this._lines[ this._lines.length - 1 ].height = cell.h;
			}

			// Add the cell to the temp word storage
			this._tempWord.push( {
				&quot;cell&quot;: cell,
				&quot;char&quot;: this.text[ i ],
				&quot;line&quot;: this._lines.length - 1,
				&quot;cw&quot;: this._tempWidth
			} );

			// This is a punction character?
			if ( this.punctionationChars.indexOf( this.text[ i ] ) !== -1 ) {

				this._addTempWord();

			}
		}
	}

	// Add the last &#x60;_tempWord&#x60; to the canvas.
	this._addTempWord();

	// Re-calculate the total height that the canvas should be.
	this._tempHeight = 0;
	for ( i = 0; i &lt; this._lines.length; i++ ) {
		this._tempHeight += this._lines[ i ].height;
	}

	if ( this._lines.length &gt; 0 ) {
		this._tempWidth = this.maxWidth;
	}
};


Kiwi.Plugins.GameObjects.BitmapText.prototype._multiLineTextBreak =
function() {

	/**
	Make the word stored in &#x60;_tempWord&#x60; break
	when it is wrapped over multiple lines.

	@method _multiLineTextBreak
	@private
	**/

	// Get the line difference...
	var j,
		l = this._tempWord[ this._tempWord.length - 1 ].line -
			this._tempWord[ 0 ].line;

	// Remove the lines that were generated by this word...
	this._lines.splice( this._lines.length - l, l );

	// Get the &quot;original&quot; width.
	this._tempWidth = this._tempWord[ 0 ].cw - this._tempWord[ 0 ].cell.w;

	// Loop through the word
	for ( j = 0; j &lt; this._tempWord.length; j++ ) {

		// Add to the width
		this._tempWidth += this._tempWord[ j ].cell.w;

		// Would it extend past the maxWidth?
		if ( this._tempWidth &gt;= this.maxWidth ) {

			// Reset the width
			this._tempWidth = this._tempWord[ j ].cell.w;

			// Generate the new line.
			this._lines.push( {
				text: [],
				height: 0,
				width: 0
			} );
		}

		// Does the height of this cell exceed the previous one?
		if ( this._lines[ this._lines.length - 1 ].height &lt;
				this._tempWord[ j ].cell.h ) {

			this._lines[ this._lines.length - 1 ].height =
				this._tempWord[ j ].cell.h;
		}

		// Add the cell to the new line.
		this._lines[ this._lines.length - 1 ].text.push(
			this._tempWord[ j ].cell );
		this._lines[ this._lines.length - 1 ].width +=
			this._tempWord[ j ].cell.w;

	}

	// Reset the temp word.
	this._tempWord.length = 0;

};


Kiwi.Plugins.GameObjects.BitmapText.prototype._renderText = function() {

	/**
	Re-calculate which character goes to which cell,
	and render the text to &#x60;_tempCanvas&#x60;.

	@method _renderText
	@private
	**/

	// Reset the width/height of the temp canvas
	this._tempWidth = 0;
	this._tempHeight = 0;

	// Reset the lines.
	this._lines = [ {
		text: [],
		height: 0,
		width: 0
	} ];

	if ( this.maxWidth === null ) {

		this._singleLineText();

	// If there is a max-width
	} else {

		this._multiLineText();

	}

	// No longer dirty as we just re-rendered it
	this._tempDirty = false;
};


Kiwi.Plugins.GameObjects.BitmapText.prototype._renderToTempCanvas =
function() {

	/**
	Render the lines/text to the temporary canvas.

	@method _renderToTempCanvas
	@private
	**/

	var cell, i, j, x, y;

	// Clear the temporary canvas.
	this._tempCtx.clearRect(
		0, 0, this._tempCanvas.width, this._tempCanvas.height );

	// Set the width/height of the canvas.
	this._tempCanvas.width = this._tempWidth;
	this._tempCanvas.height = this._tempHeight;

	// Set-up the x/y.
	x = 0;  // TODO: Check left/right/center
	y = 0;

	// Loop through the lines and render them on the temporary canvas.
	for ( j = 0; j &lt; this._lines.length; j++ ) {

		// Alignment of the lines for canvas
		if ( this.maxWidth ) {
			if ( this.align ===
				Kiwi.Plugins.GameObjects.BitmapText.RIGHT_ALIGN ) {

				x = this.maxWidth - this._lines[ j ].width;

			} else if ( this.align ===
				Kiwi.Plugins.GameObjects.BitmapText.CENTER_ALIGN ) {

				x = ( this.maxWidth - this._lines[ j ].width ) * 0.5;

			}
		}

		for ( i = 0; i &lt; this._lines[ j ].text.length; i++ ) {

			cell = this._lines[ j ].text[ i ];

			if ( typeof cell !== &quot;undefined&quot; ) {
				this._tempCtx.drawImage(
					this.atlas.image,
					cell.x , cell.y, cell.w, cell.h, x, y, cell.w, cell.h );

				x += parseInt( cell.w, 10 );
			}
		}

		x = 0;
		y += this._lines[ j ].height;

	}

};


Kiwi.Plugins.GameObjects.BitmapText.prototype._setTextureSharpness =
function( sharp ) {

	/**
	Set the sharpness of the texture atlas of this object.
	This will set the filters to NEAREST or LINEAR.

	WebGL only.

	@method _setTextureSharpness
	@param sharp {boolean=true} Whether to use LINEAR, not NEAREST
	@private
	**/

	var filter,
		gl = this.game.stage.gl,
		wrapper = this.atlas.glTextureWrapper;

	if ( !gl || !wrapper ) {
		return;
	}

	filter = sharp ? gl.LINEAR : gl.NEAREST;

	gl.bindTexture( gl.TEXTURE_2D, wrapper.texture );
	gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter );
	gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter );
	gl.bindTexture( gl.TEXTURE_2D, null );
};


Kiwi.Plugins.GameObjects.BitmapText.prototype._singleLineText = function() {

	/**
	Figure out which cell is to be used for each character in the text.
	Only for BitmapText objects that don&#x27;t have a maximum width set,
	so the text won&#x27;t be spanning multiple lines.

	Should NOT be called by the developer/external objects.

	@method _singleLineText
	@private
	**/

	var i, cell;

	for ( i = 0; i &lt; this.text.length; i++ ) {

		cell = this.atlas.cells[ this.cellNumber( this.text[ i ] ) ];

		if ( typeof cell != null ) {

			// Calculate the height.
			if ( cell.h &gt; this._tempHeight ) {
				this._tempHeight = cell.h;
			}

			// Calculate the width.
			this._tempWidth += parseInt( cell.w, 10 );
		}

		// Add the text to the next line.
		this._lines[ this._lines.length - 1 ].text.push( cell );
	}

	// Add the width.
	this._lines[ this._lines.length - 1 ].width = this._tempWidth;

};


Kiwi.Plugins.GameObjects.BitmapText.prototype.cellNumber =
function( character ) {

	/**
	Return the CELL number that will be used for a character that is passed.

	@method cellNumber
	@param character {string} Character to check
	@return {number} Cell number that will be used
	@public
	**/

	// Do we have a cell reference for that character?
	var alpha = this.alphabeticalCells[ character ];

	if ( typeof alpha === &quot;undefined&quot; ) {
		return this.defaultCell;
	} else {
		return alpha;
	}

};


Kiwi.Plugins.GameObjects.BitmapText.prototype.remap = function( obj ) {

	/**
	Update the string-cell references on &#x60;alphabeticalCells&#x60;
	based on an object that is passed.

	The object passed doesn&#x27;t have to contain every character-cell reference,
	only those that are to be changed.

	@method remap
	@param obj {object} Remap object, where characters are keys and
		cell indices are properties
	@public
	**/

	for ( var i in obj ) {
		this.alphabeticalCells[ i ] = obj[ i ];
	}

};


Kiwi.Plugins.GameObjects.BitmapText.prototype.render = function( camera ) {

	/**
	Render the text to the stage.

	@method render
	@param camera {Kiwi.Camera}
	@public
	**/

	var ctx, t, m, ct;

	if ( !(
		this.supported &amp;&amp;
		this.text != null &amp;&amp;
		this.text !== &quot;&quot; &amp;&amp;
		this.alpha &gt; 0 &amp;&amp;
		this.visible ) ) {

		return;
	}

	// Does the text need re-rendering?
	if ( this._tempDirty ) {
		this._renderText();
		this._renderToTempCanvas();
	}

	// Align text
	if ( this.align == Kiwi.Plugins.GameObjects.BitmapText.RIGHT_ALIGN ) {

		this.x -= this.width;

	} else if (
		this.align == Kiwi.Plugins.GameObjects.BitmapText.CENTER_ALIGN ) {

		this.x -= this.width / 2;

	}

	// Render on stage
	ctx = this.game.stage.ctx;
	ctx.save();

	if ( this.alpha &gt; 0 &amp;&amp; this.alpha &lt;= 1 ) {
		ctx.globalAlpha = this.alpha;
	}

	// Experimental smooth/sharp support. May not be supported by all browsers.
	ctx.imageSmoothingEnabled = this.smooth;

	t = this.transform;
	m = t.getConcatenatedMatrix();
	ct = camera.transform;

	ctx.transform(
		m.a, m.b,
		m.c, m.d,
		m.tx, m.ty );
	ctx.drawImage(
		this._tempCanvas,
		0, 0,
		this._tempCanvas.width, this._tempCanvas.height,
		-t.rotPointX, -t.rotPointY,
		this._tempCanvas.width, this._tempCanvas.height );

	ctx.restore();

	// De-align text
	if ( this.align == Kiwi.Plugins.GameObjects.BitmapText.RIGHT_ALIGN ) {

		this.x += this.width;

	} else if (
		this.align == Kiwi.Plugins.GameObjects.BitmapText.CENTER_ALIGN ) {

		this.x += this.width / 2;

	}

};


Kiwi.Plugins.GameObjects.BitmapText.prototype.renderGL =
function( gl, camera, params ) {

	/**
	Render the text via the WebGL pipeline.

	@method renderGL
	@param gl
	@param camera
	@param params
	@public
	**/

	var cell, ct, i, j, m, pt1, pt2, pt3, pt4, t, vertexItems, x, y;

	if ( !(
		this.supported &amp;&amp;
		this.text != null &amp;&amp;
		this.text !== &quot;&quot; &amp;&amp;
		this.alpha &gt; 0 &amp;&amp;
		this.visible ) ) {

		return;
	}

	// Do we need to calculate the text again?
	if ( this._tempDirty ) {
		this._renderText();
	}

	// Any alignment needed?
	if ( this.align == Kiwi.Plugins.GameObjects.BitmapText.RIGHT_ALIGN ) {

		this.x -= this.width;

	} else if (
		this.align == Kiwi.Plugins.GameObjects.BitmapText.CENTER_ALIGN ) {

		this.x -= this.width / 2;

	}

	// Set up the xyuv and alpha.
	vertexItems = [];

	// Transform/Matrix
	t = this.transform;
	m = t.getConcatenatedMatrix();
	ct = camera.transform;

	x = 0;
	y = 0;

	// Set up the Point Objects.
	pt1 = this._pt1;
	pt2 = this._pt2;
	pt3 = this._pt3;
	pt4 = this._pt4;

	// Loop through the lines and render them on the temporary canvas.
	for ( j = 0; j &lt; this._lines.length; j++ ) {

		// Alignment of the lines for canvas
		if ( this.maxWidth ) {
			if ( this.align ===
				Kiwi.Plugins.GameObjects.BitmapText.RIGHT_ALIGN ) {

				x = this.maxWidth - this._lines[ j ].width;

			} else if ( this.align ===
				Kiwi.Plugins.GameObjects.BitmapText.CENTER_ALIGN ) {

				x = ( this.maxWidth - this._lines[ j ].width ) * 0.5;

			}
		}

		// Offset anchorpoints
		x -= this.anchorPointX;
		y -= this.anchorPointY;

		for ( i = 0; i &lt; this._lines[ j ].text.length; i++ ) {

			cell = this._lines[ j ].text[ i ];

			if ( typeof cell !== &quot;undefined&quot; ) {

				pt1.setTo( x, y );
				pt2.setTo( x + cell.w, y );
				pt3.setTo( x + cell.w, y + cell.h );
				pt4.setTo( x, y + cell.h );

				pt1 = m.transformPoint( pt1 );
				pt2 = m.transformPoint( pt2 );
				pt3 = m.transformPoint( pt3 );
				pt4 = m.transformPoint( pt4 );

				vertexItems.push(

					pt1.x, pt1.y,
					cell.x, cell.y,
					this.alpha,

					pt2.x, pt2.y,
					cell.x + cell.w, cell.y,
					this.alpha,

					pt3.x, pt3.y,
					cell.x + cell.w, cell.y + cell.h,
					this.alpha,

					pt4.x, pt4.y,
					cell.x, cell.y + cell.h,
					this.alpha
				);

				x += parseInt( cell.w, 10 );

			}

		}

		x = 0;
		y += this._lines[ j ].height;
	}

	// Unalign the text
	if ( this.align ===
		Kiwi.Plugins.GameObjects.BitmapText.RIGHT_ALIGN ) {

		this.x += this.width;

	} else if ( this.align ===
		Kiwi.Plugins.GameObjects.BitmapText.CENTER_ALIGN ) {

		this.x += this.width / 2;

	}

	// Add to the batch!
	this.glRenderer.concatBatch( vertexItems );
};


/**
Constant identifying left alignment

@property LEFT_ALIGN
@static
@type number
@default 0
@public
**/

Kiwi.Plugins.GameObjects.BitmapText.LEFT_ALIGN = 0;

/**
Constant identifying right alignment

@property RIGHT_ALIGN
@static
@type number
@default 1
@public
**/

Kiwi.Plugins.GameObjects.BitmapText.RIGHT_ALIGN = 1;

/**
Constant identifying center alignment

@property CENTER_ALIGN
@static
@type number
@default 2
@public
**/

Kiwi.Plugins.GameObjects.BitmapText.CENTER_ALIGN = 2;

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
